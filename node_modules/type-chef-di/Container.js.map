{"version":3,"file":"Container.js","sourceRoot":"","sources":["../lib/Container.ts"],"names":[],"mappings":"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","sourcesContent":["import \"reflect-metadata\";\nimport { IContainer } from \"./interfaces/IContainer\";\nimport { InstantiationModeCO } from \"./chainingOptions/InstantiationModeCO\";\nimport { IInstantiatable, IInstantiationMode } from \"./interfaces/IInstantiatable\";\nimport { IResolver } from \"./interfaces/IResolver\";\nimport { ConstructorInstantiation } from \"./definitions/ConstructorInstantiation\";\nimport { ConstantInstantiation } from \"./definitions/ConstantInstantiation\";\nimport { IInterceptor } from \"./interfaces/IInterceptor\";\nimport { Initializers } from \"./modifiers/Initializers\";\nimport { Utils } from \"./Utils\";\nimport { DefinitionRepository } from \"./DefinitionRepository\";\nimport { Keys } from \"./Keys\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { Type } from \"./interfaces/IType\";\nimport { IInitializer } from \"./modifiers/initializers/IInitializer\";\nimport { IBaseDefinition } from \"./definitions/definitionInterfaces/IBaseDefinition\";\nimport { IInjectableOptions } from \"./decorators/Injectable\";\nimport { isObject, isPrimitive } from \"util\";\nimport { Logger } from \"./Logger\";\n\nexport type singletonsType = Map<string, any>;\nexport type logLevelType = \"none\" | \"debug\";\n\nexport interface IContainerOption {\n    enableAutoCreate: boolean; // if dependency not exist in the container, creat it and register\n    initializers?: Type<IInitializer>[];\n    logLevel?: logLevelType;\n}\n\n\nexport class Container implements IContainer, IResolver {\n    private logger: Logger;\n    definitionsRepository = new DefinitionRepository(this.options);\n    protected singletons: singletonsType = new Map<string, any>();\n    interceptors: IInterceptor[] = [];\n\n    initializers = new Initializers(this);\n\n    protected DEFAULT_INSTANTIATION: IInstantiationMode = \"singleton\";\n\n    constructor(public readonly options: IContainerOption = {\n        enableAutoCreate: false,\n        initializers: [],\n        logLevel: \"none\"\n    }) {\n        this.initializers.addInitializers(options.initializers || []);\n        this.logger = new Logger(Container.name, options.logLevel || \"none\");\n    }\n\n    /**\n     * Key-Value registration. You can inject the registered keys with @Inject(key) decorator\n     */\n    public register(key: string, value: any): InstantiationModeCO {\n        const decoratorTags = Utils.getMeta<string[]>(Keys.ADD_TAGS_KEY, value, []);\n        const injectableMeta = Utils.getMeta<IInjectableOptions>(Keys.INJECTABLE_KEY, value, {instantiation: this.DEFAULT_INSTANTIATION});\n        this.logger.debug(`Register:  key: ${key} --> value: ${isPrimitive(value) || isObject(value) ? JSON.stringify(value, null, 2) : Utils.logClass(value)}`);\n        this.setDefinition(key, this.getDefaultInstantiationDef(key, value, decoratorTags, injectableMeta.instantiation));\n        return new InstantiationModeCO(this, key);\n    }\n\n    /**\n     * Types registration to the container with a random key\n     * (type injection don't need keys but if {autoCreate: false} you need to register everything)\n     * @param constructors\n     */\n    public registerTypes(constructors: Type[]): void {\n        for (const constructor of constructors) {\n            if (constructor.name === \"String\" || constructor.name === \"Number\") {\n                throw new Error(`Can't register primitive as type. Please register another way: ${constructor.name}`);\n            }\n            const id = uuidv4();\n            this.logger.debug(`registerType: ${Utils.logClass(constructor)} key: ${id}`);\n            this.register(uuidv4(), constructor);\n        }\n    }\n\n    /**\n     * Resolve type\n     * @param constructor resolvable ctr\n     */\n    public async resolveByType<T>(constructor: Type<T>): Promise<T> {\n        const def = this.definitionsRepository.getDefinitionByType(constructor);\n        this.logger.debug(\"Try to resolve: \" + Utils.logClass(constructor));\n        if (def === Keys.AUTO_CREATE_DEPENDENCY && this.options.enableAutoCreate) {\n            this.logger.debug(\"AUTO_CREATE_DEPENDENCY: \" + Utils.logClass(constructor));\n            this.registerTypes([constructor]);\n            return this.resolveByType(constructor);\n        } else if (def) {\n            const instantiatable = (this.definitionsRepository.getDefinitionByType(constructor) as IInstantiatable);\n            const instance = instantiatable.instantiate();\n            return this.applyModificationToInstance(instance, instantiatable.definition);\n        } else {\n            throw new Error(`cannot resolve ${constructor}`);\n        }\n    }\n\n    /**\n     * Resolve key\n     * @param key registered key (by register(key: string, value: any))\n     */\n    public async resolve<T>(key: string): Promise<T> {\n        const instantiatable: IInstantiatable = this.definitionsRepository.getDefinition(key);\n\n        this.logger.debug(`Try to resolve key: \"${key}\" as ${instantiatable.definition.instantiationMode}`);\n        switch (instantiatable.definition.instantiationMode) {\n            case \"prototype\": {\n                const originalInstance = await this.resolvePrototype<T>(instantiatable.definition.key);\n                return this.applyModificationToInstance(originalInstance, instantiatable.definition);\n            }\n            case \"singleton\": {\n                return this.resolveSingleton<T>(instantiatable);\n            }\n            default: {\n                throw new Error(`Cannot resolve: ${key} because instantiationMode is:  ${instantiatable.definition.instantiationMode}`);\n            }\n        }\n    }\n\n    async applyModificationToInstance(instance: any, definition: IBaseDefinition) {\n        instance = await this.initializers.runInitializers(instance, definition);\n        return instance;\n    }\n\n    async resolveByTags(tags: string | string[]): Promise<any[]> {\n        if (typeof tags === \"string\") { tags = [tags]; }\n        const keys = this.definitionsRepository.getDefinitionKeysBySpecificTags(tags);\n\n        const result = [];\n        for (const key of keys) {\n            result.push(await this.resolve(key));\n        }\n\n        return result;\n    }\n\n    addInterceptor(interceptor: IInterceptor): void {\n        this.interceptors.push(interceptor);\n    }\n\n\n    /**\n     * resolve test for all keys.\n     */\n    async containerTest() {\n        for (const key of this.definitionsRepository.definitions.keys()) {\n            try {\n                await this.resolve<any>(key);\n            } catch (err) {\n                throw new Error(`Not proper registration. details: ${err}`);\n            }\n        }\n    }\n\n    /**\n     * run interceptors. Run this after all key was registered.\n     */\n    async done(): Promise<any> {\n        await this.containerTest();\n        this.runInterceptors();\n    }\n\n    private runInterceptors() {\n        this.interceptors.forEach((interceptor: IInterceptor) => {\n            interceptor.intercept(this);\n        });\n    }\n\n    hasKeyInDefinition(key: string): boolean {\n        return this.definitionsRepository.definitions.has(key);\n    }\n\n    private setDefinition(key: string, definition: IInstantiatable) {\n        this.definitionsRepository.definitions.set(key, definition);\n    }\n\n    private getDefaultInstantiationDef(key: string, content: any, decoratorTags: string[], instantiationMode?: IInstantiationMode): IInstantiatable {\n\n        if (Utils.isClass(content)) {\n            const classInstance = new ConstructorInstantiation({\n                key,\n                content,\n                context: {},\n                instantiationMode: instantiationMode || this.DEFAULT_INSTANTIATION,\n            }, this);\n            classInstance.tags = [...decoratorTags];\n            return classInstance;\n        }\n        return new ConstantInstantiation({\n            key,\n            content,\n            instantiationMode: this.DEFAULT_INSTANTIATION\n        });\n    }\n\n    private async resolvePrototype<T>(key: string): Promise<T> {\n        return this.definitionsRepository.getDefinition(key).instantiate();\n    }\n\n    private async resolveSingleton<T>(instantiatable: IInstantiatable): Promise<T> {\n        if (!this.singletons.has(instantiatable.definition.key)) {\n            let newInstance = await instantiatable.instantiate();\n            newInstance = this.applyModificationToInstance(newInstance, instantiatable.definition);\n\n            this.singletons.set(instantiatable.definition.key, newInstance);\n            return this.singletons.get(instantiatable.definition.key);\n        }\n        return this.singletons.get(instantiatable.definition.key);\n    }\n\n    private getTagsMeta(ctr: Type) {\n        if (!Utils.isClass(ctr)) return;\n        const meta = Reflect.getMetadata(Keys.ADD_TAGS_KEY, ctr.prototype) || {};\n        return meta[Keys.ADD_TAGS_KEY] || [];\n    }\n}\n"]}