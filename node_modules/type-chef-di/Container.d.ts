import "reflect-metadata";
import { IContainer } from "./interfaces/IContainer";
import { InstantiationModeCO } from "./chainingOptions/InstantiationModeCO";
import { IInstantiationMode } from "./interfaces/IInstantiatable";
import { IResolver } from "./interfaces/IResolver";
import { IInterceptor } from "./interfaces/IInterceptor";
import { Initializers } from "./modifiers/Initializers";
import { DefinitionRepository } from "./DefinitionRepository";
import { Type } from "./interfaces/IType";
import { IInitializer } from "./modifiers/initializers/IInitializer";
import { IBaseDefinition } from "./definitions/definitionInterfaces/IBaseDefinition";
export declare type singletonsType = Map<string, any>;
export declare type logLevelType = "none" | "debug";
export interface IContainerOption {
    enableAutoCreate: boolean;
    initializers?: Type<IInitializer>[];
    logLevel?: logLevelType;
}
export declare class Container implements IContainer, IResolver {
    readonly options: IContainerOption;
    private logger;
    definitionsRepository: DefinitionRepository;
    protected singletons: singletonsType;
    interceptors: IInterceptor[];
    initializers: Initializers;
    protected DEFAULT_INSTANTIATION: IInstantiationMode;
    constructor(options?: IContainerOption);
    /**
     * Key-Value registration. You can inject the registered keys with @Inject(key) decorator
     */
    register(key: string, value: any): InstantiationModeCO;
    /**
     * Types registration to the container with a random key
     * (type injection don't need keys but if {autoCreate: false} you need to register everything)
     * @param constructors
     */
    registerTypes(constructors: Type[]): void;
    /**
     * Resolve type
     * @param constructor resolvable ctr
     */
    resolveByType<T>(constructor: Type<T>): Promise<T>;
    /**
     * Resolve key
     * @param key registered key (by register(key: string, value: any))
     */
    resolve<T>(key: string): Promise<T>;
    applyModificationToInstance(instance: any, definition: IBaseDefinition): Promise<any>;
    resolveByTags(tags: string | string[]): Promise<any[]>;
    addInterceptor(interceptor: IInterceptor): void;
    /**
     * resolve test for all keys.
     */
    containerTest(): Promise<void>;
    /**
     * run interceptors. Run this after all key was registered.
     */
    done(): Promise<any>;
    private runInterceptors;
    hasKeyInDefinition(key: string): boolean;
    private setDefinition;
    private getDefaultInstantiationDef;
    private resolvePrototype;
    private resolveSingleton;
    private getTagsMeta;
}
