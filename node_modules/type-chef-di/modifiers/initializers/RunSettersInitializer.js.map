{"version":3,"file":"RunSettersInitializer.js","sourceRoot":"","sources":["../../../lib/modifiers/initializers/RunSettersInitializer.ts"],"names":[],"mappings":";;;;;;;;;;;;AACA,qCAAkC;AAClC,uEAAoE;AAGpE,MAAa,qBAAqB;IAG9B,YAAqB,QAAmB;QAAnB,aAAQ,GAAR,QAAQ,CAAW;QAFxC,gBAAW,GAAgB,IAAI,yBAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IAG1D,CAAC;IAEK,GAAG,CAAC,gBAAqB,EAAE,UAAe;;YAC5C,OAAO,IAAI,CAAC,UAAU,CAAC,gBAAgB,EAAE,UAAU,CAAC,CAAC;QACzD,CAAC;KAAA;IAEK,UAAU,CAAC,gBAAqB,EAAE,UAAe;;YACnD,MAAM,cAAc,GAAG,OAAO,CAAC,WAAW,CAAC,WAAI,CAAC,oCAAoC,EAAE,UAAU,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC;YAChH,MAAM,aAAa,GAAa,cAAc,CAAC,WAAI,CAAC,oCAAoC,CAAC,CAAC;YAC1F,IAAI,aAAa,KAAK,SAAS,IAAI,aAAa,CAAC,MAAM,IAAI,CAAC;gBAAE,OAAO,gBAAgB,CAAC;YACtF,KAAK,MAAM,YAAY,IAAI,aAAa,EAAE;gBACtC,IAAI,YAAY,KAAK,SAAS,EAAE;oBAC5B,MAAM,gBAAgB,GAAG,OAAO,CAAC,WAAW,CAAC,YAAY,EAAE,UAAU,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC;oBACrF,MAAM,YAAY,GAAQ,CAAA,MAAM,IAAI,CAAC,WAAW,CAAC,gBAAgB,CAAC,gBAAgB,EAAE,UAAU,CAAC,OAAO,EAAE,YAAY,CAAC,KAAI,EAAE,CAAC;oBAC5H,IAAI,YAAY,CAAC,MAAM,GAAG,CAAC,EAAE;wBACzB,MAAM,IAAI,KAAK,CAAC,qEAAqE,YAAY,EAAE,CAAC,CAAC;qBACxG;oBACD,IAAI;wBACA,gBAAgB,CAAC,YAAY,CAAC,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC;qBACpD;oBAAC,OAAO,GAAG,EAAE;wBACV,MAAM,IAAI,KAAK,CAAC,wGAAwG,CAAC,CAAC;qBAC7H;iBACJ;aACJ;YACD,OAAO,gBAAgB,CAAC;QAC5B,CAAC;KAAA;CACJ;AA9BD,sDA8BC","sourcesContent":["import { IInitializer } from \"./IInitializer\";\nimport { Keys } from \"../../Keys\";\nimport { ArgResolver } from \"../../definitions/helpers/ArgResolver\";\nimport { IResolver } from \"../../interfaces/IResolver\";\n\nexport class RunSettersInitializer implements IInitializer {\n    argResolver: ArgResolver = new ArgResolver(this.resolver);\n\n    constructor(readonly resolver: IResolver) {\n    }\n\n    async run(resolvedInstance: any, definition: any): Promise<any> {\n        return this.runSetters(resolvedInstance, definition);\n    }\n\n    async runSetters(resolvedInstance: any, definition: any): Promise<any> {\n        const initMethodMeta = Reflect.getMetadata(Keys.SETTER_METHOD_PROPERTY_DECORATOR_KEY, definition.content) || {};\n        const setterMethods: string[] = initMethodMeta[Keys.SETTER_METHOD_PROPERTY_DECORATOR_KEY];\n        if (setterMethods === undefined || setterMethods.length <= 0) return resolvedInstance;\n        for (const setterMethod of setterMethods) {\n            if (setterMethod !== undefined) {\n                const setterParamsMeta = Reflect.getMetadata(setterMethod, definition.content) || {};\n                const setterFnArgs: any = await this.argResolver.resolveArguments(setterParamsMeta, definition.context, setterMethod) || [];\n                if (setterFnArgs.length > 1) {\n                    throw new Error(`@Setter method too many args (pleas pass 1 @inject('key') arg) to ${setterMethod}`);\n                }\n                try {\n                    resolvedInstance[setterMethod] = setterFnArgs[0];\n                } catch (err) {\n                    throw new Error(\"@Setter method only allowed to setters (example: @Setter() set setVariable(@Inject('key') param){...})\");\n                }\n            }\n        }\n        return resolvedInstance;\n    }\n}\n"]}