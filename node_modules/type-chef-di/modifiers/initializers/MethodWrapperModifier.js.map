{"version":3,"file":"MethodWrapperModifier.js","sourceRoot":"","sources":["../../../lib/modifiers/initializers/MethodWrapperModifier.ts"],"names":[],"mappings":";;;;;;;;;;;;AACA,qCAAkC;AAIlC,MAAa,qBAAqB;IAE9B,YAAqB,QAAmB;QAAnB,aAAQ,GAAR,QAAQ,CAAW;IACxC,CAAC;IAEK,GAAG,CAAC,QAAa,EAAE,UAAe;;YACpC,OAAO,IAAI,CAAC,gBAAgB,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAC;QACvD,CAAC;KAAA;IAEK,gBAAgB,CAAC,gBAAqB,EAAE,UAAe;;YACzD,MAAM,WAAW,GAAG,OAAO,CAAC,WAAW,CAAC,WAAI,CAAC,kBAAkB,EAAE,gBAAgB,CAAC,WAAW,CAAC,IAAI,EAAE,CAAC;YACrG,IAAI,CAAC,WAAW;gBAAE,OAAO,gBAAgB,CAAC;YAE1C,KAAK,MAAM,GAAG,IAAI,WAAW,EAAE;gBAC3B,MAAM,eAAe,GAAoB,OAAO,WAAW,CAAC,GAAG,CAAC,KAAK,QAAQ,CAAC,CAAC,CAAC,MAAM,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC;gBACpL,MAAM,kBAAkB,GAAG,OAAO,CAAC,WAAW,CAAC,WAAI,CAAC,qBAAqB,EAAE,gBAAgB,CAAC,WAAW,CAAC,IAAI,EAAE,CAAC;gBAC/G,gBAAgB,CAAC,GAAG,CAAC,GAAI,UAA2B,GAAG,IAAS;;wBAC5D,OAAO,eAAe,CAAC,GAAG,CAAC,GAAG,EAAE,WAAC,OAAA,MAAA,kBAAkB,CAAC,KAAK,0CAAE,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAA,EAAA,EAAE,IAAI,CAAC,CAAC;oBACxF,CAAC;iBAAA,CAAC;aACL;YAED,OAAO,gBAAgB,CAAC;QAC5B,CAAC;KAAA;CAEJ;AAxBD,sDAwBC","sourcesContent":["import { IResolver } from \"../../interfaces/IResolver\";\nimport { Keys } from \"../../Keys\";\nimport { IMethodWrapper } from \"../../interfaces/IMethodWrapper\";\nimport { IInitializer } from \"./IInitializer\";\n\nexport class MethodWrapperModifier implements IInitializer {\n\n    constructor(readonly resolver: IResolver) {\n    }\n\n    async run(instance: any, definition: any): Promise<any> {\n        return this.setMethodWrapper(instance, definition);\n    }\n\n    async setMethodWrapper(resolvedInstance: any, definition: any) {\n        const wrapperMeta = Reflect.getMetadata(Keys.METHOD_WRAPPER_KEY, resolvedInstance.constructor) || {};\n        if (!wrapperMeta) return resolvedInstance;\n\n        for (const key in wrapperMeta) {\n            const resolveRunAfter: IMethodWrapper =  typeof wrapperMeta[key] === \"string\" ? await this.resolver.resolve(wrapperMeta[key]) : await this.resolver.resolveByType(wrapperMeta[key]);\n            const descriptorOriginal = Reflect.getMetadata(Keys.METHOD_DESCRIPTOR_KEY, resolvedInstance.constructor) || {};\n            resolvedInstance[key] =  async function (this: any, ...args: any) {\n                return resolveRunAfter.run(() => descriptorOriginal.value?.apply(this, args), args);\n            };\n        }\n\n        return resolvedInstance;\n    }\n\n}\n"]}