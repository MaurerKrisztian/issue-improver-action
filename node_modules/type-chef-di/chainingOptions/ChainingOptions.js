"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChainingOptions = void 0;
const Keys_1 = require("../Keys");
const ConstantInstantiation_1 = require("../definitions/ConstantInstantiation");
const FactoryInstantiation_1 = require("../definitions/FactoryInstantiation");
const FactoryResultInstantiation_1 = require("../definitions/FactoryResultInstantiation");
const ConstructorInstantiation_1 = require("../definitions/ConstructorInstantiation");
class ChainingOptions {
    constructor(container, key) {
        this.container = container;
        this.key = key;
        this.instantiable = this.container.definitionsRepository.getDefinition(key);
    }
    setDefinitionChanges() {
        this.container.definitionsRepository.definitions.set(this.key, this.instantiable);
    }
    asPrototype() {
        this.instantiable.definition.instantiationMode = 'prototype';
        this.setDefinitionChanges();
        return this;
    }
    asSingleton() {
        this.instantiable.definition.instantiationMode = 'singleton';
        this.setDefinitionChanges();
        return this;
    }
    asConstant() {
        this.instantiable = new ConstantInstantiation_1.ConstantInstantiation({
            key: this.key,
            content: this.instantiable.definition.content,
            instantiationMode: this.instantiable.definition.instantiationMode
        });
        this.setDefinitionChanges();
        return this;
    }
    /*
    * set the @FactoryMethod meta to definition or asFactory() param or 'create'
    * */
    asFactory(factoryFnName) {
        const getFactoryMethod = (ctr) => {
            const meta = Reflect.getMetadata(Keys_1.Keys.FACTORY_METHOD_PROPERTY_DECORATOR_KEY, ctr) || {};
            return meta[Keys_1.Keys.FACTORY_METHOD_PROPERTY_DECORATOR_KEY];
        };
        const factoryDefinition = {
            key: this.key,
            content: this.instantiable.definition.content,
            factoryFn: "create",
            instantiationMode: this.instantiable.definition.instantiationMode
        };
        const metaFactoryMethod = getFactoryMethod(this.instantiable.definition.content);
        if (factoryFnName !== undefined) {
            factoryDefinition.factoryFn = factoryFnName;
        }
        else if (metaFactoryMethod !== undefined) {
            factoryDefinition.factoryFn = metaFactoryMethod;
        }
        else {
            factoryDefinition.factoryFn = "create";
        }
        this.instantiable = new FactoryInstantiation_1.FactoryInstantiation(factoryDefinition, this.container);
        this.setDefinitionChanges();
        return this;
    }
    asFactoryResult(factoryKey) {
        const factory = this.container.definitionsRepository.getDefinition(factoryKey);
        if (!(factory instanceof FactoryInstantiation_1.FactoryInstantiation)) {
            throw new Error("factoryKey is not a factory");
        }
        this.instantiable = new FactoryResultInstantiation_1.FactoryResultInstantiation({
            key: this.key,
            content: this.instantiable.definition.content,
            factoryKey,
            factoryMethodContext: {},
            instantiationMode: this.instantiable.definition.instantiationMode
        }, this.container);
        this.setDefinitionChanges();
        return this;
    }
    withContext(context) {
        if (!(this.instantiable instanceof ConstructorInstantiation_1.ConstructorInstantiation || this.instantiable instanceof FactoryInstantiation_1.FactoryInstantiation)) {
            throw new Error("cannot set context to  " + this.instantiable.definition.key);
        }
        this.instantiable.definition.context = context;
        this.setDefinitionChanges();
        return this;
    }
    withMethodContext(context) {
        if (!(this.instantiable instanceof FactoryResultInstantiation_1.FactoryResultInstantiation)) {
            throw new Error("cannot set context to  " + this.instantiable.definition.key);
        }
        this.instantiable.definition.factoryMethodContext = context;
        this.setDefinitionChanges();
        return this;
    }
    addTags(tags) {
        this.container.definitionsRepository.addTags(this.key, tags);
    }
}
exports.ChainingOptions = ChainingOptions;
//# sourceMappingURL=ChainingOptions.js.map