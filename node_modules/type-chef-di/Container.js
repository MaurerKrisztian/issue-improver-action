"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Container = void 0;
require("reflect-metadata");
const InstantiationModeCO_1 = require("./chainingOptions/InstantiationModeCO");
const ConstructorInstantiation_1 = require("./definitions/ConstructorInstantiation");
const ConstantInstantiation_1 = require("./definitions/ConstantInstantiation");
const Initializers_1 = require("./modifiers/Initializers");
const Utils_1 = require("./Utils");
const DefinitionRepository_1 = require("./DefinitionRepository");
const Keys_1 = require("./Keys");
const uuid_1 = require("uuid");
const util_1 = require("util");
const Logger_1 = require("./Logger");
class Container {
    constructor(options = {
        enableAutoCreate: false,
        initializers: [],
        logLevel: "none"
    }) {
        this.options = options;
        this.definitionsRepository = new DefinitionRepository_1.DefinitionRepository(this.options);
        this.singletons = new Map();
        this.interceptors = [];
        this.initializers = new Initializers_1.Initializers(this);
        this.DEFAULT_INSTANTIATION = "singleton";
        this.initializers.addInitializers(options.initializers || []);
        this.logger = new Logger_1.Logger(Container.name, options.logLevel || "none");
    }
    /**
     * Key-Value registration. You can inject the registered keys with @Inject(key) decorator
     */
    register(key, value) {
        const decoratorTags = Utils_1.Utils.getMeta(Keys_1.Keys.ADD_TAGS_KEY, value, []);
        const injectableMeta = Utils_1.Utils.getMeta(Keys_1.Keys.INJECTABLE_KEY, value, { instantiation: this.DEFAULT_INSTANTIATION });
        this.logger.debug(`Register:  key: ${key} --> value: ${(0, util_1.isPrimitive)(value) || (0, util_1.isObject)(value) ? JSON.stringify(value, null, 2) : Utils_1.Utils.logClass(value)}`);
        this.setDefinition(key, this.getDefaultInstantiationDef(key, value, decoratorTags, injectableMeta.instantiation));
        return new InstantiationModeCO_1.InstantiationModeCO(this, key);
    }
    /**
     * Types registration to the container with a random key
     * (type injection don't need keys but if {autoCreate: false} you need to register everything)
     * @param constructors
     */
    registerTypes(constructors) {
        for (const constructor of constructors) {
            if (constructor.name === "String" || constructor.name === "Number") {
                throw new Error(`Can't register primitive as type. Please register another way: ${constructor.name}`);
            }
            const id = (0, uuid_1.v4)();
            this.logger.debug(`registerType: ${Utils_1.Utils.logClass(constructor)} key: ${id}`);
            this.register((0, uuid_1.v4)(), constructor);
        }
    }
    /**
     * Resolve type
     * @param constructor resolvable ctr
     */
    resolveByType(constructor) {
        return __awaiter(this, void 0, void 0, function* () {
            const def = this.definitionsRepository.getDefinitionByType(constructor);
            this.logger.debug("Try to resolve: " + Utils_1.Utils.logClass(constructor));
            if (def === Keys_1.Keys.AUTO_CREATE_DEPENDENCY && this.options.enableAutoCreate) {
                this.logger.debug("AUTO_CREATE_DEPENDENCY: " + Utils_1.Utils.logClass(constructor));
                this.registerTypes([constructor]);
                return this.resolveByType(constructor);
            }
            else if (def) {
                const instantiatable = this.definitionsRepository.getDefinitionByType(constructor);
                const instance = instantiatable.instantiate();
                return this.applyModificationToInstance(instance, instantiatable.definition);
            }
            else {
                throw new Error(`cannot resolve ${constructor}`);
            }
        });
    }
    /**
     * Resolve key
     * @param key registered key (by register(key: string, value: any))
     */
    resolve(key) {
        return __awaiter(this, void 0, void 0, function* () {
            const instantiatable = this.definitionsRepository.getDefinition(key);
            this.logger.debug(`Try to resolve key: "${key}" as ${instantiatable.definition.instantiationMode}`);
            switch (instantiatable.definition.instantiationMode) {
                case "prototype": {
                    const originalInstance = yield this.resolvePrototype(instantiatable.definition.key);
                    return this.applyModificationToInstance(originalInstance, instantiatable.definition);
                }
                case "singleton": {
                    return this.resolveSingleton(instantiatable);
                }
                default: {
                    throw new Error(`Cannot resolve: ${key} because instantiationMode is:  ${instantiatable.definition.instantiationMode}`);
                }
            }
        });
    }
    applyModificationToInstance(instance, definition) {
        return __awaiter(this, void 0, void 0, function* () {
            instance = yield this.initializers.runInitializers(instance, definition);
            return instance;
        });
    }
    resolveByTags(tags) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof tags === "string") {
                tags = [tags];
            }
            const keys = this.definitionsRepository.getDefinitionKeysBySpecificTags(tags);
            const result = [];
            for (const key of keys) {
                result.push(yield this.resolve(key));
            }
            return result;
        });
    }
    addInterceptor(interceptor) {
        this.interceptors.push(interceptor);
    }
    /**
     * resolve test for all keys.
     */
    containerTest() {
        return __awaiter(this, void 0, void 0, function* () {
            for (const key of this.definitionsRepository.definitions.keys()) {
                try {
                    yield this.resolve(key);
                }
                catch (err) {
                    throw new Error(`Not proper registration. details: ${err}`);
                }
            }
        });
    }
    /**
     * run interceptors. Run this after all key was registered.
     */
    done() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.containerTest();
            this.runInterceptors();
        });
    }
    runInterceptors() {
        this.interceptors.forEach((interceptor) => {
            interceptor.intercept(this);
        });
    }
    hasKeyInDefinition(key) {
        return this.definitionsRepository.definitions.has(key);
    }
    setDefinition(key, definition) {
        this.definitionsRepository.definitions.set(key, definition);
    }
    getDefaultInstantiationDef(key, content, decoratorTags, instantiationMode) {
        if (Utils_1.Utils.isClass(content)) {
            const classInstance = new ConstructorInstantiation_1.ConstructorInstantiation({
                key,
                content,
                context: {},
                instantiationMode: instantiationMode || this.DEFAULT_INSTANTIATION,
            }, this);
            classInstance.tags = [...decoratorTags];
            return classInstance;
        }
        return new ConstantInstantiation_1.ConstantInstantiation({
            key,
            content,
            instantiationMode: this.DEFAULT_INSTANTIATION
        });
    }
    resolvePrototype(key) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.definitionsRepository.getDefinition(key).instantiate();
        });
    }
    resolveSingleton(instantiatable) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.singletons.has(instantiatable.definition.key)) {
                let newInstance = yield instantiatable.instantiate();
                newInstance = this.applyModificationToInstance(newInstance, instantiatable.definition);
                this.singletons.set(instantiatable.definition.key, newInstance);
                return this.singletons.get(instantiatable.definition.key);
            }
            return this.singletons.get(instantiatable.definition.key);
        });
    }
    getTagsMeta(ctr) {
        if (!Utils_1.Utils.isClass(ctr))
            return;
        const meta = Reflect.getMetadata(Keys_1.Keys.ADD_TAGS_KEY, ctr.prototype) || {};
        return meta[Keys_1.Keys.ADD_TAGS_KEY] || [];
    }
}
exports.Container = Container;
//# sourceMappingURL=Container.js.map