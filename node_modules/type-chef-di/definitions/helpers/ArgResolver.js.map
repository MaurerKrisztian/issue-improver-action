{"version":3,"file":"ArgResolver.js","sourceRoot":"","sources":["../../../lib/definitions/helpers/ArgResolver.ts"],"names":[],"mappings":";;;;;;;;;;;;AAEA,qCAAkC;AAElC,MAAa,WAAW;IAEpB,YAA6B,QAAmB;QAAnB,aAAQ,GAAR,QAAQ,CAAW;IAChD,CAAC;IAED,kBAAkB,CAAC,KAAuB;QACtC,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,kBAAkB,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,CAAA,KAAK,aAAL,KAAK,uBAAL,KAAK,CAAE,UAAU,CAAA,CAAC;IAC9E,CAAC;IAEK,gBAAgB,CAAC,IAAS,EAAE,OAAY,EAAE,YAA6B;;YACzE,IAAI,IAAI,GAAuB,IAAI,CAAC,YAAY,CAAC,CAAC;YAClD,IAAI,CAAC,IAAI;gBAAE,OAAO,EAAE,CAAC;YACrB,IAAI,OAAO,EAAE;gBACT,IAAI,GAAG,IAAI,CAAC,gBAAgB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;aAC/C;YAED,MAAM,YAAY,GAAG,EAAE,CAAC;YACxB,KAAK,MAAM,GAAG,IAAI,IAAI,EAAE;gBACpB,IAAI,CAAC,GAAG,IAAI,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,gBAAgB,EAAE;oBAChD,YAAY,CAAC,IAAI,CAAC,WAAI,CAAC,wBAAwB,CAAC,CAAC;iBACpD;qBAAM,IAAI,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,EAAE;oBACrC,YAAY,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;iBAChC;qBAAM;oBACH,YAAY,CAAC,IAAI,CAAC,OAAO,GAAG,CAAC,GAAG,KAAK,QAAQ,CAAC,CAAC,CAAC,MAAM,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,MAAM,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;iBACtJ;aACJ;YACD,OAAO,YAAY,CAAC;QACxB,CAAC;KAAA;IAED,gBAAgB,CAAC,IAAwB,EAAE,GAAQ;QAC/C,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC,GAAqB,EAAE,EAAE;YACtC,IAAI,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;gBACd,OAAO,EAAC,GAAG,EAAE,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,UAAU,EAAE,GAAG,CAAC,UAAU,EAAE,KAAK,EAAE,GAAG,CAAC,KAAK,EAAC,CAAC;aAC5E;YACD,OAAO,GAAG,CAAC;QACf,CAAC,CAAC,CAAC;IACP,CAAC;CACJ;AArCD,kCAqCC","sourcesContent":["import { IResolver } from \"../../interfaces/IResolver\";\nimport { IInjectParamMeta } from \"../../decorators/Inject\";\nimport { Keys } from \"../../Keys\";\n\nexport class ArgResolver {\n\n    constructor(private readonly resolver: IResolver) {\n    }\n\n    paramIsNotRequired(param: IInjectParamMeta): boolean {\n        return !this.resolver.hasKeyInDefinition(param.key) && !param?.isRequired;\n    }\n\n    async resolveArguments(meta: any, context: any, decoratorKey: symbol | string): Promise<any[]> {\n        let args: IInjectParamMeta[] = meta[decoratorKey];\n        if (!args) return [];\n        if (context) {\n            args = this.mapContextToArgs(args, context);\n        }\n\n        const resolvedArgs = [];\n        for (const arg of args) {\n            if (!arg && this.resolver.options.enableAutoCreate) {\n                resolvedArgs.push(Keys.OTHER_INJECTION_REQUIRED);\n            } else if (this.paramIsNotRequired(arg)) {\n                resolvedArgs.push(undefined);\n            } else {\n                resolvedArgs.push(typeof arg.key === \"string\" ? await this.resolver.resolve(arg.key, arg.isRequired) : await this.resolver.resolveByType(arg.key));\n            }\n        }\n        return resolvedArgs;\n    }\n\n    mapContextToArgs(args: IInjectParamMeta[], ctx: any): IInjectParamMeta[] {\n        return args.map((arg: IInjectParamMeta) => {\n            if (ctx[arg.key]) {\n                return {key: ctx[arg.key], isRequired: arg.isRequired, index: arg.index};\n            }\n            return arg;\n        });\n    }\n}\n"]}