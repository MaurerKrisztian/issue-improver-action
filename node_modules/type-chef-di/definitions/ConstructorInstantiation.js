"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConstructorInstantiation = void 0;
const Keys_1 = require("../Keys");
const ArgResolver_1 = require("./helpers/ArgResolver");
const Utils_1 = require("../Utils");
class ConstructorInstantiation {
    constructor(definition, resolver) {
        this.resolver = resolver;
        this.tags = [];
        this.definition = definition;
        this.argResolver = new ArgResolver_1.ArgResolver(resolver);
    }
    instantiate() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.resolveConstructor(this.definition.content, this.definition.context, Keys_1.Keys.INJECT_PROPERTY_DECORATOR_KEY);
        });
    }
    resolveParentArgs(ctr) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = [];
            const parentCtr = Object.getPrototypeOf(ctr);
            const parentArgs = Reflect.getMetadata("design:paramtypes", parentCtr) || [];
            for (const parentArg of parentArgs) {
                args.push(yield this.resolver.resolveByType(parentArg));
            }
            return args;
        });
    }
    /*
    * If has OTHER_INJECTION_REQUIRED arg (arg without key), this function will inject by type
    *  - if enable AutoCreate in the options then if the container item not found it will create and register
    * */
    resolveArgsWithoutKey(ctr, args) {
        return __awaiter(this, void 0, void 0, function* () {
            const constructorArgs = Reflect.getMetadata("design:paramtypes", ctr) || [];
            // correction if 0 param in constructorArgs
            if (args.length === 0) {
                for (let i = 0; i < Utils_1.Utils.getRequiredParamLength(ctr); i++) {
                    args.push(Keys_1.Keys.OTHER_INJECTION_REQUIRED);
                }
            }
            for (let i = 0; i < args.length; i++) {
                if (args[i] === Keys_1.Keys.OTHER_INJECTION_REQUIRED) {
                    args[i] = yield this.resolver.resolveByType(constructorArgs[i]);
                }
            }
            return args;
        });
    }
    isResolvable(ctr) {
        const meta = Reflect.getMetadata(Keys_1.Keys.INJECT_PROPERTY_DECORATOR_KEY, ctr) || {};
        const constructorArgs = Reflect.getMetadata("design:paramtypes", ctr) || [];
        const propsMeta = meta[Keys_1.Keys.INJECT_PROPERTY_DECORATOR_KEY] || [];
        for (let i = 0; i < constructorArgs.length; i++) {
            if (!propsMeta[i] && !this.resolver.options.enableAutoCreate) {
                throw new Error(`Can't resolve: ${Utils_1.Utils.logClass(ctr, i)} maybe try to register it or use {enableAutoCreate: true}`);
            }
            else if (!propsMeta[i] && this.resolver.options.enableAutoCreate && Utils_1.Utils.isPrimitiveCtr(constructorArgs[i])) {
                throw new Error(`Can't resolve primitive without registration ${Utils_1.Utils.logClass(ctr, i)}`);
            }
        }
    }
    resolveConstructor(ctr, context, decoratorKey) {
        return __awaiter(this, void 0, void 0, function* () {
            this.isResolvable(ctr);
            const meta = Reflect.getMetadata(decoratorKey, ctr) || {};
            let args = yield this.argResolver.resolveArguments(meta, context, Keys_1.Keys.INJECT_PROPERTY_DECORATOR_KEY);
            if (args.length === 0) {
                args = yield this.resolveParentArgs(ctr);
            }
            if (this.resolver.options.enableAutoCreate) {
                args = yield this.resolveArgsWithoutKey(ctr, args);
            }
            return new ctr(...args);
        });
    }
}
exports.ConstructorInstantiation = ConstructorInstantiation;
//# sourceMappingURL=ConstructorInstantiation.js.map